#!/usr/bin/env python3
# coding: utf-8

import csv
import sys

def create_graph(my_list):
    my_map = {}
    for line in my_list:
        my_map[line[0]] = line[3:]
    return my_map

def find_all_paths(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return [path]
    if start not in graph:
        return []
    paths = []
    for node in graph[start]:
        if node not in path:
            newpaths = find_all_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
    return paths

def find_longest_path(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if start not in graph:
        return None
    longest = None
    for node in graph[start]:
        if node not in path:
            newpath = find_longest_path(graph, node, end, path)
            if newpath:
                if not longest or len(newpath) < len(longest):
                    longest = newpath
        return longest

def test(my_key, my_graph, task):
    paths = []
    for key in my_key:
        paths += find_all_paths(my_graph, key, task)
    print(paths)

with open(sys.argv[1], newline='') as csvfile:
    timetable = csv.reader(csvfile, delimiter=';')
    my_list = []
    my_root = []
    for line in timetable:
        if len(line) < 4:
            my_root.append(line[0])
        my_list.append(line)


my_graph = create_graph(my_list)
#print(my_list)
#print()
#test(my_root, my_graph, my_list[5][0])
#print(my_graph)
for elem in my_graph:
    print(elem, my_graph[elem])
print(find_all_paths(my_graph, 'Ele', my_root[0]))

print(find_longest_path(my_graph, 'Ele', my_root[0]))

